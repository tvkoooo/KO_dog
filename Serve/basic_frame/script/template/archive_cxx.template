//
//	Generated by lua
<#
	local timecode = tostring(os.date("%Y", os.time()))
#>
<#="//	copyright longer "..timecode.."\n"#>
//  mm_<#=ctx.file_tag#>.cpp

#include "mm_<#=ctx.file_tag#>.h"

namespace mm
{
<#
for _,evt in ipairs(ctx.data.event) do
	if evt.define=="msg" or evt.define=="struct" then
#>
	//
	//	struct implementation for <#=evt.name#>
	//
	<#=evt.name#>::~<#=evt.name#>()
	{

	}
	<#=evt.name#>::<#=evt.name#>()
<#
	local num2=0
	local sign2
	for _,attr in ipairs(evt.attributes) do
		if attr.default then
			num2=num2+1
			if num2==1 then
				sign2=":"
			else
				sign2=","
			end
#>
		<#=sign2#><#=ctx.vname(attr.name)#>(<#=attr.default#>)
<#
		end
	end
#>
	{

	}
<#
		if evt.define == "msg" then
#>
	mm_uint32_t <#=evt.name#>::unique() const
	{
		return Id;
	}
<#
		end
#>
	void <#=evt.name#>::encode(mm_o_archive& archive) const
	{
<#
		if evt.base and not evt.virtual_base then
#>
		<#=evt.base#>::encode(archive);
<#
		end
#>
<#
	for _,attr in ipairs(evt.attributes) do
#>
		archive << <#=ctx.vname(attr.name)#>;
<#
	end
#>
	}
	void <#=evt.name#>::decode(const mm_i_archive& archive)
	{
<#
		if evt.base and not evt.virtual_base then
#>
		<#=evt.base#>::decode(archive);
<#
		end
#>
<#
	for _,attr in ipairs(evt.attributes) do
#>
		archive >> <#=ctx.vname(attr.name)#>;
<#
	end
#>
	}
<#
	else
#>

<#
	end
end
#>
}