//
//	Generated by lua
//	copyright longer 2019
//  mm_q_db_ko_dog_t_nt_message.cpp

#include "mm_q_db_ko_dog_t_nt_message.h"

namespace mm
{
	//
	//	struct definition for p_nt_message_add	//
	p_nt_message_add::~p_nt_message_add()
	{

	}
	p_nt_message_add::p_nt_message_add()
		:code(0)
		,user_id(0)
		,to_user_id(0)
		,message_mid(0)
		,nt_message("")
		,note_id(0)
	{

	}
	void p_nt_message_add::encode(mm_o_archive& archive) const
	{
		archive << code;
		archive << user_id;
		archive << to_user_id;
		archive << message_mid;
		archive << nt_message;
		archive << note_id;
	}
	void p_nt_message_add::decode(const mm_i_archive& archive)
	{
		archive >> code;
		archive >> user_id;
		archive >> to_user_id;
		archive >> message_mid;
		archive >> nt_message;
		archive >> note_id;
	}
	int p_nt_message_add::query(struct mm_db_mysql* _sql, mm_uint32_t logger_level)
	{
		int error_code = db_mysql_state_unknown;
		struct mm_logger* g_logger = mm_logger_instance();
		assert(NULL != _sql && "p_nt_message_add input struct mm_db_mysql is a null.");
		mm_db_mysql_query db(_sql);
		mm_db_mysql_stream oss( mm_db_mysql_get_context( _sql ) );
		mm_db_mysql_lock(_sql);
		oss
			<< "call db_ko_dog.p_nt_message_add("
			<< " " << "@code"
			<< ",'" << user_id << "'"
			<< ",'" << to_user_id << "'"
			<< ",'" << message_mid << "'"
			<< ",'" << nt_message << "'" << " );"
			<< "select "
			<< " " << "@code" << "  ;";
		const std::string& sql_str = oss.get_string();
		mm_logger_message(g_logger,logger_level,"dump sql:%s",sql_str.c_str());
		if ( 0 == mm_db_mysql_real_query( _sql, sql_str.c_str() ) )
		{
			// result 1.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 1 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				if ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
					db.get_field( 0, note_id );
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// result 2.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 1 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				if ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
					db.get_field( 0, code );
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// free unused result.
			mm_db_mysql_free_unused_result(_sql);
			//
			error_code = db_mysql_state_success;
		}
		else
		{
			error_code = db_mysql_state_failure;
		}
		mm_db_mysql_unlock(_sql);
		return error_code;
	}
	//
	//	struct definition for p_nt_message_delete_by_id	//
	p_nt_message_delete_by_id::~p_nt_message_delete_by_id()
	{

	}
	p_nt_message_delete_by_id::p_nt_message_delete_by_id()
		:code(0)
		,note_id(0)
	{

	}
	void p_nt_message_delete_by_id::encode(mm_o_archive& archive) const
	{
		archive << code;
		archive << note_id;
	}
	void p_nt_message_delete_by_id::decode(const mm_i_archive& archive)
	{
		archive >> code;
		archive >> note_id;
	}
	int p_nt_message_delete_by_id::query(struct mm_db_mysql* _sql, mm_uint32_t logger_level)
	{
		int error_code = db_mysql_state_unknown;
		struct mm_logger* g_logger = mm_logger_instance();
		assert(NULL != _sql && "p_nt_message_delete_by_id input struct mm_db_mysql is a null.");
		mm_db_mysql_query db(_sql);
		mm_db_mysql_stream oss( mm_db_mysql_get_context( _sql ) );
		mm_db_mysql_lock(_sql);
		oss
			<< "call db_ko_dog.p_nt_message_delete_by_id("
			<< " " << "@code"
			<< ",'" << note_id << "'" << " );"
			<< "select "
			<< " " << "@code" << "  ;";
		const std::string& sql_str = oss.get_string();
		mm_logger_message(g_logger,logger_level,"dump sql:%s",sql_str.c_str());
		if ( 0 == mm_db_mysql_real_query( _sql, sql_str.c_str() ) )
		{
			// result 1.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 1 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				if ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
					db.get_field( 0, code );
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// free unused result.
			mm_db_mysql_free_unused_result(_sql);
			//
			error_code = db_mysql_state_success;
		}
		else
		{
			error_code = db_mysql_state_failure;
		}
		mm_db_mysql_unlock(_sql);
		return error_code;
	}
	//
	//	struct definition for p_nt_message_read_by_note_id	//
	p_nt_message_read_by_note_id::~p_nt_message_read_by_note_id()
	{

	}
	p_nt_message_read_by_note_id::p_nt_message_read_by_note_id()
		:code(0)
		,note_id(0)
	{

	}
	void p_nt_message_read_by_note_id::encode(mm_o_archive& archive) const
	{
		archive << code;
		archive << note_id;
		archive << nt_message_s;
	}
	void p_nt_message_read_by_note_id::decode(const mm_i_archive& archive)
	{
		archive >> code;
		archive >> note_id;
		archive >> nt_message_s;
	}
	int p_nt_message_read_by_note_id::query(struct mm_db_mysql* _sql, mm_uint32_t logger_level)
	{
		int error_code = db_mysql_state_unknown;
		struct mm_logger* g_logger = mm_logger_instance();
		assert(NULL != _sql && "p_nt_message_read_by_note_id input struct mm_db_mysql is a null.");
		mm_db_mysql_query db(_sql);
		mm_db_mysql_stream oss( mm_db_mysql_get_context( _sql ) );
		mm_db_mysql_lock(_sql);
		oss
			<< "call db_ko_dog.p_nt_message_read_by_note_id("
			<< " " << "@code"
			<< ",'" << note_id << "'" << " );"
			<< "select "
			<< " " << "@code" << "  ;";
		const std::string& sql_str = oss.get_string();
		mm_logger_message(g_logger,logger_level,"dump sql:%s",sql_str.c_str());
		if ( 0 == mm_db_mysql_real_query( _sql, sql_str.c_str() ) )
		{
			// result 1.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 7 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				typedef nt_message_vec::iterator iterator; 
				mm_uint64_t _affected_rows = mm_db_mysql_get_affected_rows(_sql);
				// std list vector resize(size_t n, value_type()), value_type can not contain shared pointer.
				// here we can safe resize.
				nt_message_s.resize((size_t)_affected_rows);
				for (iterator it = nt_message_s.begin();
					it!=nt_message_s.end();++it)
				{
					if ( 0 != mm_db_mysql_get_has_row(_sql) )
					{
						t_nt_message& v = *it;
						db.get_field( 0, v.note_id );
						db.get_field( 1, v.read_state );
						db.get_field( 2, v.to_user_id );
						db.get_field( 3, v.user_id );
						db.get_field( 4, v.message_mid );
						db.get_field( 5, v.create_time );
						db.get_field( 6, v.nt_message );
					}
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// result 2.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 1 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				if ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
					db.get_field( 0, code );
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// free unused result.
			mm_db_mysql_free_unused_result(_sql);
			//
			error_code = db_mysql_state_success;
		}
		else
		{
			error_code = db_mysql_state_failure;
		}
		mm_db_mysql_unlock(_sql);
		return error_code;
	}
	//
	//	struct definition for p_nt_message_read_by_to_user_id	//
	p_nt_message_read_by_to_user_id::~p_nt_message_read_by_to_user_id()
	{

	}
	p_nt_message_read_by_to_user_id::p_nt_message_read_by_to_user_id()
		:code(0)
		,to_user_id(0)
	{

	}
	void p_nt_message_read_by_to_user_id::encode(mm_o_archive& archive) const
	{
		archive << code;
		archive << to_user_id;
		archive << nt_message_s;
	}
	void p_nt_message_read_by_to_user_id::decode(const mm_i_archive& archive)
	{
		archive >> code;
		archive >> to_user_id;
		archive >> nt_message_s;
	}
	int p_nt_message_read_by_to_user_id::query(struct mm_db_mysql* _sql, mm_uint32_t logger_level)
	{
		int error_code = db_mysql_state_unknown;
		struct mm_logger* g_logger = mm_logger_instance();
		assert(NULL != _sql && "p_nt_message_read_by_to_user_id input struct mm_db_mysql is a null.");
		mm_db_mysql_query db(_sql);
		mm_db_mysql_stream oss( mm_db_mysql_get_context( _sql ) );
		mm_db_mysql_lock(_sql);
		oss
			<< "call db_ko_dog.p_nt_message_read_by_to_user_id("
			<< " " << "@code"
			<< ",'" << to_user_id << "'" << " );"
			<< "select "
			<< " " << "@code" << "  ;";
		const std::string& sql_str = oss.get_string();
		mm_logger_message(g_logger,logger_level,"dump sql:%s",sql_str.c_str());
		if ( 0 == mm_db_mysql_real_query( _sql, sql_str.c_str() ) )
		{
			// result 1.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 7 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				typedef nt_message_vec::iterator iterator; 
				mm_uint64_t _affected_rows = mm_db_mysql_get_affected_rows(_sql);
				// std list vector resize(size_t n, value_type()), value_type can not contain shared pointer.
				// here we can safe resize.
				nt_message_s.resize((size_t)_affected_rows);
				for (iterator it = nt_message_s.begin();
					it!=nt_message_s.end();++it)
				{
					if ( 0 != mm_db_mysql_get_has_row(_sql) )
					{
						t_nt_message& v = *it;
						db.get_field( 0, v.note_id );
						db.get_field( 1, v.read_state );
						db.get_field( 2, v.to_user_id );
						db.get_field( 3, v.user_id );
						db.get_field( 4, v.message_mid );
						db.get_field( 5, v.create_time );
						db.get_field( 6, v.nt_message );
					}
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// result 2.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 1 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				if ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
					db.get_field( 0, code );
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// free unused result.
			mm_db_mysql_free_unused_result(_sql);
			//
			error_code = db_mysql_state_success;
		}
		else
		{
			error_code = db_mysql_state_failure;
		}
		mm_db_mysql_unlock(_sql);
		return error_code;
	}
	//
	//	struct definition for p_nt_message_consume_by_note_id	//
	p_nt_message_consume_by_note_id::~p_nt_message_consume_by_note_id()
	{

	}
	p_nt_message_consume_by_note_id::p_nt_message_consume_by_note_id()
		:code(0)
		,to_user_id(0)
		,note_id(0)
	{

	}
	void p_nt_message_consume_by_note_id::encode(mm_o_archive& archive) const
	{
		archive << code;
		archive << to_user_id;
		archive << note_id;
	}
	void p_nt_message_consume_by_note_id::decode(const mm_i_archive& archive)
	{
		archive >> code;
		archive >> to_user_id;
		archive >> note_id;
	}
	int p_nt_message_consume_by_note_id::query(struct mm_db_mysql* _sql, mm_uint32_t logger_level)
	{
		int error_code = db_mysql_state_unknown;
		struct mm_logger* g_logger = mm_logger_instance();
		assert(NULL != _sql && "p_nt_message_consume_by_note_id input struct mm_db_mysql is a null.");
		mm_db_mysql_query db(_sql);
		mm_db_mysql_stream oss( mm_db_mysql_get_context( _sql ) );
		mm_db_mysql_lock(_sql);
		oss
			<< "call db_ko_dog.p_nt_message_consume_by_note_id("
			<< " " << "@code"
			<< ",'" << to_user_id << "'"
			<< ",'" << note_id << "'" << " );"
			<< "select "
			<< " " << "@code" << "  ;";
		const std::string& sql_str = oss.get_string();
		mm_logger_message(g_logger,logger_level,"dump sql:%s",sql_str.c_str());
		if ( 0 == mm_db_mysql_real_query( _sql, sql_str.c_str() ) )
		{
			// result 1.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 1 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				if ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
					db.get_field( 0, code );
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// free unused result.
			mm_db_mysql_free_unused_result(_sql);
			//
			error_code = db_mysql_state_success;
		}
		else
		{
			error_code = db_mysql_state_failure;
		}
		mm_db_mysql_unlock(_sql);
		return error_code;
	}
	//
	//	struct definition for p_nt_message_consume_by_max_note_id	//
	p_nt_message_consume_by_max_note_id::~p_nt_message_consume_by_max_note_id()
	{

	}
	p_nt_message_consume_by_max_note_id::p_nt_message_consume_by_max_note_id()
		:code(0)
		,to_user_id(0)
		,note_id(0)
	{

	}
	void p_nt_message_consume_by_max_note_id::encode(mm_o_archive& archive) const
	{
		archive << code;
		archive << to_user_id;
		archive << note_id;
	}
	void p_nt_message_consume_by_max_note_id::decode(const mm_i_archive& archive)
	{
		archive >> code;
		archive >> to_user_id;
		archive >> note_id;
	}
	int p_nt_message_consume_by_max_note_id::query(struct mm_db_mysql* _sql, mm_uint32_t logger_level)
	{
		int error_code = db_mysql_state_unknown;
		struct mm_logger* g_logger = mm_logger_instance();
		assert(NULL != _sql && "p_nt_message_consume_by_max_note_id input struct mm_db_mysql is a null.");
		mm_db_mysql_query db(_sql);
		mm_db_mysql_stream oss( mm_db_mysql_get_context( _sql ) );
		mm_db_mysql_lock(_sql);
		oss
			<< "call db_ko_dog.p_nt_message_consume_by_max_note_id("
			<< " " << "@code"
			<< ",'" << to_user_id << "'"
			<< ",'" << note_id << "'" << " );"
			<< "select "
			<< " " << "@code" << "  ;";
		const std::string& sql_str = oss.get_string();
		mm_logger_message(g_logger,logger_level,"dump sql:%s",sql_str.c_str());
		if ( 0 == mm_db_mysql_real_query( _sql, sql_str.c_str() ) )
		{
			// result 1.
			mm_db_mysql_store_next_result(_sql);
			{
				assert( 1 == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				if ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
					db.get_field( 0, code );
				}
			}
			mm_db_mysql_free_current_result(_sql);
			// free unused result.
			mm_db_mysql_free_unused_result(_sql);
			//
			error_code = db_mysql_state_success;
		}
		else
		{
			error_code = db_mysql_state_failure;
		}
		mm_db_mysql_unlock(_sql);
		return error_code;
	}
	//
	//	struct definition for p_nt_message_regular_clean	//
	p_nt_message_regular_clean::~p_nt_message_regular_clean()
	{

	}
	p_nt_message_regular_clean::p_nt_message_regular_clean()
		:unread_day(0)
		,read_day(0)
	{

	}
	void p_nt_message_regular_clean::encode(mm_o_archive& archive) const
	{
		archive << unread_day;
		archive << read_day;
	}
	void p_nt_message_regular_clean::decode(const mm_i_archive& archive)
	{
		archive >> unread_day;
		archive >> read_day;
	}
	int p_nt_message_regular_clean::query(struct mm_db_mysql* _sql, mm_uint32_t logger_level)
	{
		int error_code = db_mysql_state_unknown;
		struct mm_logger* g_logger = mm_logger_instance();
		assert(NULL != _sql && "p_nt_message_regular_clean input struct mm_db_mysql is a null.");
		mm_db_mysql_query db(_sql);
		mm_db_mysql_stream oss( mm_db_mysql_get_context( _sql ) );
		mm_db_mysql_lock(_sql);
		oss
			<< "call db_ko_dog.p_nt_message_regular_clean("
			<< " '" << unread_day << "'"
			<< ",'" << read_day << "'" << " );";
		const std::string& sql_str = oss.get_string();
		mm_logger_message(g_logger,logger_level,"dump sql:%s",sql_str.c_str());
		if ( 0 == mm_db_mysql_real_query( _sql, sql_str.c_str() ) )
		{
			// free unused result.
			mm_db_mysql_free_unused_result(_sql);
			//
			error_code = db_mysql_state_success;
		}
		else
		{
			error_code = db_mysql_state_failure;
		}
		mm_db_mysql_unlock(_sql);
		return error_code;
	}
}