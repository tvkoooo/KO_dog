//
//	Generated by lua
<#
	local timecode = tostring(os.date("%Y", os.time()))
#>
<#="//	copyright longer "..timecode.."\n"#>
//  mm_<#=ctx.file_tag#>.cpp

<#
	local _tab_base = ""
	local _tab_str = "\n\t\t\t".._tab_base
	function queryer_format(sqlarg)
		local _i_var_sign = "'"
		local _o_var_sign = ""
		local sql_string = ""
		if sqlarg then
			local sql_func = ""
			for _,func_elem in ipairs(sqlarg) do
				sql_func = ""
				local sign_call = " "
				local sql_call = _tab_str.."<< \""..func_elem.function_name..func_elem.fl.."\""
				for _,attr in ipairs(func_elem.variable) do
					if "o" == attr.kind then
						sql_call = sql_call.._tab_str
						sql_call = sql_call.."<< \""
						sql_call = sql_call..sign_call
						sql_call = sql_call.._o_var_sign
						sql_call = sql_call.."\" << ".."\"@"..attr.var
						sql_call = sql_call.._o_var_sign
						sql_call = sql_call.."\""
					elseif "i" == attr.kind then
						sql_call = sql_call.._tab_str
						sql_call = sql_call.."<< \""
						sql_call = sql_call..sign_call
						sql_call = sql_call.._i_var_sign
						sql_call = sql_call.."\" << "..attr.var.." << \""
						sql_call = sql_call.._i_var_sign
						sql_call = sql_call.."\""
					end
					if " " == sign_call then
						sign_call = ","
					end
				end
				sql_func = sql_call.." << \" "..func_elem.fr..";\""
				sql_string = sql_string..sql_func
			end
		end
		return sql_string
	end
#>
#include "mm_<#=ctx.file_tag#>.h"

namespace mm
{
<#
	for _,evt in ipairs(ctx.data.event) do
		if evt.define=="msg" or evt.define=="struct" then
#>
	//
	//	struct definition for <#=evt.name#>
	//
	<#=evt.name#>::~<#=evt.name#>()
	{

	}
<#
			if #(evt.attributes)~=0 then
#>
	<#=evt.name#>::<#=evt.name#>()
<#
				local num2=0
				local sign2
				for _,attr in ipairs(evt.attributes) do
					if attr.default then
						num2=num2+1
						if num2==1 then
							sign2=":"
						else
							sign2=","
						end
#>
		<#=sign2#><#=ctx.vname(attr.name)#>(<#=attr.default#>)
<#
					end
				end
#>
	{

	}
<#
			end
#>
<#
			if evt.define == "msg" then
#>
	mm_uint32_t <#=evt.name#>::unique() const
	{
		return Id;
	}
<#
			end
#>
	void <#=evt.name#>::encode(mm_o_archive& archive) const
	{
<#
			if evt.base and not evt.virtual_base then
#>
		<#=evt.base#>::encode(archive);
<#
			end
#>
<#
			for _,attr in ipairs(evt.attributes) do
#>
		archive << <#=ctx.vname(attr.name)#>;
<#
			end
#>
	}
	void <#=evt.name#>::decode(const mm_i_archive& archive)
	{
<#
			if evt.base and not evt.virtual_base then
#>
		<#=evt.base#>::decode(archive);
<#
			end
#>
<#
			for _,attr in ipairs(evt.attributes) do
#>
		archive >> <#=ctx.vname(attr.name)#>;
<#
			end
#>
	}
	int <#=evt.name#>::query(struct mm_db_mysql* _sql, mm_uint32_t logger_level)
	{
		int error_code = db_mysql_state_unknown;
		struct mm_logger* g_logger = mm_logger_instance();
		assert(NULL != _sql && "<#=evt.name#> input struct mm_db_mysql is a null.");
		mm_db_mysql_query db(_sql);
<#
			local sqlstr = queryer_format(evt.handler.sql)
			-- print(sqlstr)
#>
		mm_db_mysql_stream oss( mm_db_mysql_get_context( _sql ) );
		mm_db_mysql_lock(_sql);
		oss<#=sqlstr#>;
		const std::string& sql_str = oss.get_string();
		mm_logger_message(g_logger,logger_level,"dump sql:%s",sql_str.c_str());
		if ( 0 == mm_db_mysql_real_query( _sql, sql_str.c_str() ) )
		{
<#
			local output = evt.handler.output
			for _okey,_oval in ipairs(output) do
				local _oval_count = #_oval.variable
#>
			// result <#=_okey#>.
<#
				if _oval.container_kind then
#>
<#
					if _oval.container_kind=="map" then
#>
			mm_db_mysql_store_next_result(_sql);
			{
				assert( <#=_oval_count#> == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				typedef <#=_oval.container_type#>::value_type value_type;
				while ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
					<#=_oval.elem_type#> <#=_oval.elem_name#>;
<#
						local outIdx = 0
						for _,attr in ipairs(_oval.variable) do
#>
					db.get_field( <#=outIdx#>, <#=attr#> );
<#
							outIdx = outIdx+1;
						end
#>
					<#=_oval.container_name#>.insert( value_type( <#=_oval.key#>, <#=_oval.elem_name#> ) );
				}
			}
			mm_db_mysql_free_current_result(_sql);
<#
					elseif _oval.container_kind=="list" or _oval.container_kind=="vector" then
#>
			mm_db_mysql_store_next_result(_sql);
			{
				assert( <#=_oval_count#> == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				typedef <#=_oval.container_type#>::iterator iterator; 
				mm_uint64_t _affected_rows = mm_db_mysql_get_affected_rows(_sql);
				// std list vector resize(size_t n, value_type()), value_type can not contain shared pointer.
				// here we can safe resize.
				<#=_oval.container_name#>.resize((size_t)_affected_rows);
				for (iterator it = <#=_oval.container_name#>.begin();
					it!=<#=_oval.container_name#>.end();++it)
				{
					if ( 0 != mm_db_mysql_get_has_row(_sql) )
					{
						<#=_oval.elem_type#>& <#=_oval.elem_name#> = *it;
<#
						local outIdx = 0
						for _,attr in ipairs(_oval.variable) do
#>
						db.get_field( <#=outIdx#>, <#=attr#> );
<#
							outIdx = outIdx+1;
						end
#>
					}
				}
			}
			mm_db_mysql_free_current_result(_sql);
<#
					end
#>
<#
				else
					if _oval.variable then
#>
			mm_db_mysql_store_next_result(_sql);
			{
				assert( <#=_oval_count#> == mm_db_mysql_get_field_count(_sql) && "field count is not match.");
				if ( 0 != mm_db_mysql_get_has_row(_sql) )
				{
<#
						local outIdx = 0
						for _,attr in ipairs(_oval.variable) do
#>
					db.get_field( <#=outIdx#>, <#=attr#> );
<#
							outIdx = outIdx+1;
						end
#>
				}
			}
			mm_db_mysql_free_current_result(_sql);
<#
					end
				end
			end
#>
			// free unused result.
			mm_db_mysql_free_unused_result(_sql);
			//
			error_code = db_mysql_state_success;
		}
		else
		{
			error_code = db_mysql_state_failure;
		}
		mm_db_mysql_unlock(_sql);
		return error_code;
	}
<#
		else
#>

<#
		end
	end
#>
}