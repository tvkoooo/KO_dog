//
//	Generated by lua
<#
	local timecode = tostring(os.date("%Y", os.time()))
#>
<#="//	copyright longer "..timecode.."\n"#>
//  mm_<#=ctx.file_tag#>.h

#ifndef __mm_<#=ctx.file_tag#>_h__
#define __mm_<#=ctx.file_tag#>_h__

<#
	if ctx.data.include_file ~= nul then
#>
<#
		for _,attr in ipairs(ctx.data.include_file) do
#>
#include <#=attr.."\n"#>
<#
		end
#>
<#
	end
#>

namespace mm
{
<#
for _,evt in ipairs(ctx.data.event) do
	if evt.define=="msg" or evt.define=="struct" then
#>
	//
	//	struct definition for <#=evt.name#>
	//
	struct <#=evt.name#>
<#
		if evt.base then
#>
 : public <#=evt.base.."\n"#>
<#
		end
#>
	{
<#
	if evt.define == "msg" then
#>
	public:
		enum{ KeyH = <#=evt.KeyH#> , KeyL = <#=evt.KeyL#> , Id = ( KeyH << 16 ) | KeyL };
<#
	end
#>
<#
	if evt.typedef ~= nul then
#>
	public:
<#
		for _,attr in ipairs(evt.typedef) do
#>
		typedef <#=ctx.types(attr.type)#> <#=attr.name#>;
<#
		end
#>
<#
	end
#>
<#
	if #(evt.attributes)~=0 then
#>
	public:
<#
	for _,attr in ipairs(evt.attributes) do
		local evt_elem_name=ctx.types(attr.type)
		attr.typedef_name=evt_elem_name
		local desc_str = ""
		if attr.desc then
			desc_str = "// "..attr.desc
		end
#>
		<#=evt_elem_name#> <#=ctx.vname(attr.name)#>;<#=desc_str.."\n"#>
<#
	end
#>
<#
	end
#>
	public:
		virtual ~<#=evt.name#>();
<#
	if #(evt.attributes)~=0 then
#>
	public:
		<#=evt.name#>();
<#
	end
#>
<#
		if evt.define == "msg" then
#>
		virtual mm_uint32_t unique()const;
<#
		end
#>
		virtual void encode(mm_o_archive& archive) const;
		virtual void decode(const mm_i_archive& archive);
	};
<#
	else
#>

<#
	end
end
#>
}
#endif//__dish_<#=ctx.file_tag#>_h__